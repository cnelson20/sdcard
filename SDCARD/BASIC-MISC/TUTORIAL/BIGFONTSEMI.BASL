REM VOIDSTAR - DEC 2023

  DIM BIT.MASK(8)
	REM 11000000 -> 00110000 -> 00001100 -> 00000011
	REM 0 2 4 6 --> SINCE WE STEP BY 2 DURING LOOP 0 TO 7
	BIT.MASK(0) = $C0
	BIT.MASK(2) = $30
	BIT.MASK(4) = $0C
	BIT.MASK(6) = $03

  REM DENOM = 2^(6-IDX) WHERE IDX LOOPS 0 TO 7 STEP 2
	REM 2^(6-0) = 2^6 = 2*2*2*2*2*2 = 64
	REM 2^(6-2) = 2^4 = 2*2*2*2     = 16
	REM 2^(6-4) = 2^2 = 2*2         = 4
	REM 2^(6-6) = 2^0               = 1	
	DIM DENOM(8)
	DENOM(0) = 64
	DENOM(2) = 16
	DENOM(4) = 4
	DENOM(6) = 1	

	DIM BIG.PRINT.RESULT(16) : REM WIP - THIS IS SINGLE CHARACTER RESULT, NOT ENTIRE STRING
	
  DIM SEMI.GRAPHIC.SYMBOLS(16)
  RESTORE SEMI.GRAPHICS.SYMBOL.DATA : REM ENSURE READ POINTER SET TO START OF THE SYMBOL DATA
	I=0
INIT.NEXT.SYMBOL.DATA:	  
	READ A
	IF A<>-1 THEN SEMI.GRAPHIC.SYMBOLS(I)=A:I=I+1:GOTO INIT.NEXT.SYMBOL.DATA
		
  A=RND(0)
  REM SCREEN 11
  CLS

	PRINT "TYPE IN A SHORT ONE LINE PHRASE:"
  PRINT ">";
	
	REM LIMITING TO 31 ONLY BECAUSE OUTPUT GETS WRITTEN TO VRAM- IF CHANGE THAT TO A FILE
	REM WE COULD DO LONG STRINGS.
  GET.SOME.INPUT.MAXLEN=31:REM ANY NEGATIVE VALUES GO TO MAX.LENGTH OF CURRENT ROW
	
  GOSUB GET.SOME.INPUT
  PRINT "[";GET.SOME.INPUT.RESULT$;"]"
	BIG.PRINT.STRING$ = GET.SOME.INPUT.RESULT$	
	
	GOSUB BIG.PRINT.EXECUTE	

	LOCATE KERNAL.SCREEN.ROW-2,1
  END

REM **************************************************
REM **************************************************
BIG.PRINT.EXECUTE:  
  BIG.PRINT.STRING.LEN = LEN(BIG.PRINT.STRING$)	
	
	REM GET THE CURRENT ROW SO WE CAN WRITE THE RESULT DIRECTLY TO THIS ROW...
	GOSUB KERNAL.PLOT.GET
	TMP.ROW = KERNAL.PLOT.ROW

  TMP.COL = 0	: REM MANAGE WHICH COLUMN THE PRINTED RESULT WILL BE DISPLAYED
	FOR I = 1 TO BIG.PRINT.STRING.LEN
	
	  A$=MID$(BIG.PRINT.STRING$,I,1):A = ASC(A$)		
		GOSUB PETSCII.TO.DISPLAYCODE.CVT : REM C = RESULTING DISPLAY CODE 
		
		FONT.BASE = 61440+C*8 : REM *8 SINCE WE KNOW VRAM FONTS ARE 8 PIXELS(BITS) WIDE (61440 == $F000)
		
		FOR FONT.ROW.IDX = 0 TO 7 STEP 2 : REM EACH ROW OF THE FONT...

      IDX=FONT.BASE+FONT.ROW.IDX:A1=VPEEK(1,IDX):A2=VPEEK(1,IDX+1)			
			FONT.ROW.IDX.HALF = INT(FONT.ROW.IDX/2) : REM THIS COULD BE A LUT(LOOK UP TABLE) ALSO...
			
			FOR FONT.COL.IDX = 0 TO 7 STEP 2 : REM 0 2 4 6
			
			  BIT.MASK=BIT.MASK(FONT.COL.IDX):DENOM=DENOM(FONT.COL.IDX)
				
			  A1.TMP=INT((A1 AND BIT.MASK)/DENOM):A2.TMP=INT((A2 AND BIT.MASK)/DENOM)

				REM ACCUMULATE CLOCKWISE
				CODE.IDX=0
				IF (A1.TMP AND 2) THEN CODE.IDX = CODE.IDX OR 8
				IF (A1.TMP AND 1) THEN CODE.IDX = CODE.IDX OR 4
				IF (A2.TMP AND 1) THEN CODE.IDX = CODE.IDX OR 2
				IF (A2.TMP AND 2) THEN CODE.IDX = CODE.IDX OR 1				

				TMP.IDX = INT(FONT.ROW.IDX.HALF*4)+INT(FONT.COL.IDX/2) : REM *4 SINCE WE KNOW WIDTH IS 4
				BIG.PRINT.RESULT(TMP.IDX) = SEMI.GRAPHIC.SYMBOLS(CODE.IDX)		

			NEXT FONT.COL.IDX

		NEXT FONT.ROW.IDX

	  REM WRITE OUT THE GENERATED SEMIGRAPHIC CHARACTER...		
		REM NOTE: CODE COULD BE MODIFIED TO ADAPT SCREEN CODE BACK TO PETSCII AND STORE IN RAM STRING INSTEAD
		FOR TMP.IDX.X = 0 TO 3
			TILE TMP.COL+TMP.IDX.X,TMP.ROW,BIG.PRINT.RESULT(TMP.IDX.X)			 : REM  0 IS ROW 1
			TILE TMP.COL+TMP.IDX.X,TMP.ROW+1,BIG.PRINT.RESULT(4+TMP.IDX.X)	 : REM  4 IS ROW 2		
			TILE TMP.COL+TMP.IDX.X,TMP.ROW+2,BIG.PRINT.RESULT(8+TMP.IDX.X)	 : REM  8 IS ROW 3
			TILE TMP.COL+TMP.IDX.X,TMP.ROW+3,BIG.PRINT.RESULT(12+TMP.IDX.X)  : REM 12 IS ROW 4
		NEXT TMP.IDX.X
		
		TMP.COL = TMP.COL + 4 : REM 4 SINCE FONT IS 4X4
		
	NEXT I

  RETURN

REM THESE ARE SCREEN DISPLAY CODES FOR THE 16 SEMIGRAPHICS USED TO MAKE THE "BIG FONT"
SEMI.GRAPHICS.SYMBOL.DATA:
DATA 32
DATA 123
DATA 108
DATA 98
DATA 124
DATA 255
DATA 225
DATA 254
DATA 126
DATA 97
DATA 127
DATA 252
DATA 226
DATA 236
DATA 251
DATA 160
DATA -1

REM **************************************************
REM **************************************************
GET.SOME.INPUT:

  GOSUB KERNAL.PLOT.GET
	
	REM GET THE SCREEN CONTENT AT WHERE WE ARE NOW
  SCREEN.CONTENT.COL=KERNAL.PLOT.COL
  SCREEN.CONTENT.ROW=KERNAL.PLOT.ROW
  GOSUB SCREEN.CONTENT.GET

  REM GET THE CURRENT SIZE OF THE TEXT MODE SCREEN, SO WE CAN KEEP THE INPUT TO A SINGLE LINE
  GOSUB KERNAL.SCREEN.GET

  REM ABSOLUTE MAX (SCREEN COL WIDTH MINUS STARTING CURSOR COLUMN)
  GET.SOME.INPUT.ABSMAX = KERNAL.SCREEN.COL - KERNAL.PLOT.COL

  REM IF A NEGATIVE MAXLEN IS SPECIFIED, THEN DEFAULT IT BACK TO THE MAX COMPUTED LENGTH
  IF GET.SOME.INPUT.MAXLEN<0 THEN GET.SOME.INPUT.MAXLEN=GET.SOME.INPUT.ABSMAX
 
  IF GET.SOME.INPUT.MAXLEN <= GET.SOME.INPUT.ABSMAX THEN GOTO GET.SOME.INPUT.START
  GET.SOME.INPUT.MAXLEN = GET.SOME.INPUT.ABSMAX

GET.SOME.INPUT.START:
  GET.SOME.INPUT.RESULT$ = ""
  INPUT.QUERY.LENGTH=0

GET.SOME.INPUT.GET:  
  GOSUB KERNAL.PLOT.GET
  TILE KERNAL.PLOT.COL,KERNAL.PLOT.ROW,INT(RND(.)*256),INT(RND(.)*16)
  GET INPUT.QUERY$:IF INPUT.QUERY$="" THEN GOTO GET.SOME.INPUT.GET

  INPUT.QUERY = ASC(INPUT.QUERY$)

  IF INPUT.QUERY=13 THEN GOTO GET.SOME.INPUT.EXIT:REM PETSCII 13 IS RETURN/ENTER

  REM PETSCII 20 IS BACKSPACE
  IF INPUT.QUERY<>20 THEN GOTO GET.SOME.INPUT.VALIDS
  REM HANDLE BACKSPACE...
  IF LEN(GET.SOME.INPUT.RESULT$)<=0 THEN GOTO GET.SOME.INPUT.GET
  GOSUB KERNAL.PLOT.GET
  TILE KERNAL.PLOT.COL,KERNAL.PLOT.ROW,SCREEN.CONTENT.CHAR,SCREEN.CONTENT.COLOR
  GET.SOME.INPUT.RESULT$=LEFT$(GET.SOME.INPUT.RESULT$,LEN(GET.SOME.INPUT.RESULT$)-1)
  PRINT CHR$(157);" ";CHR$(157);  
  INPUT.QUERY.LENGTH=INPUT.QUERY.LENGTH-1
	GOTO GET.SOME.INPUT.GET

GET.SOME.INPUT.VALIDS:
  IF INPUT.QUERY.LENGTH=GET.SOME.INPUT.MAXLEN THEN GOTO GET.SOME.INPUT.ERROR
	
	IF INPUT.QUERY>=0 AND INPUT.QUERY<32 THEN GOTO GET.SOME.INPUT.ERROR    :REM LOWER (FIRST) 32
	IF INPUT.QUERY>=128 AND INPUT.QUERY<160 THEN GOTO GET.SOME.INPUT.ERROR :REM UPPER (INVERTED) 32
	
	REM ALTERNATIVELY - YOU CAN FILTER DOWN INTO SPECIFIC ALPHA-NUMERICS YOU WANT TO MAKE ACCAPTABLE...	
	REM IF INPUT.QUERY>=193 AND INPUT.QUERY<=218 THEN GOTO GET.SOME.INPUT.KEEP   : REM LOWER CASE IN CERTAIN MODES
  REM IF INPUT.QUERY$>="a" AND INPUT.QUERY$<="z" THEN GOTO GET.SOME.INPUT.KEEP
  REM IF INPUT.QUERY$>="A" AND INPUT.QUERY$<="Z" THEN GOTO GET.SOME.INPUT.KEEP
  REM IF INPUT.QUERY$>="0" AND INPUT.QUERY$<="9" THEN GOTO GET.SOME.INPUT.KEEP
  REM IF INPUT.QUERY$="-" OR INPUT.QUERY$="!" THEN GOTO GET.SOME.INPUT.KEEP
  REM IF INPUT.QUERY$=" " THEN GOTO GET.SOME.INPUT.KEEP
  REM GOTO GET.SOME.INPUT.GET

GET.SOME.INPUT.KEEP:
  INPUT.QUERY.LENGTH=INPUT.QUERY.LENGTH+1
  GET.SOME.INPUT.RESULT$=GET.SOME.INPUT.RESULT$+INPUT.QUERY$
  PRINT INPUT.QUERY$;
  GOTO GET.SOME.INPUT.GET

GET.SOME.INPUT.ERROR:
  PRINT CHR$(7);:REM BELL
  GOTO GET.SOME.INPUT.GET

GET.SOME.INPUT.EXIT:
  REM CLEAN UP THE LAST NON-PRINTABLE CHARACTER (RETURN/ENTER)
  GOSUB KERNAL.PLOT.GET
  TILE KERNAL.PLOT.COL,KERNAL.PLOT.ROW,SCREEN.CONTENT.CHAR,SCREEN.CONTENT.COLOR
  PRINT
  RETURN

KERNAL.PLOT.GET:
  REM GET CURSOR X/Y POSITION (X=ROW, Y=COLUMN)
  REM RESULT WRITTEN TO KERNAL.PLOT.R AND KERNAL.PLOT.C
  POKE $030F,1  REM SET CARRY FLAG TO GET X/Y
  SYS $FFF0 REM CALL PLOT
  KERNAL.PLOT.ROW=PEEK($030D) REM GET REGISTER X RESULT (ROW)
  KERNAL.PLOT.COL=PEEK($030E) REM GET REGISTER Y RESULT (COL)
  RETURN

KERNAL.SCREEN.GET:
  SYS $FFED:REM SYS CALL TO GET CURRENT SCREEN RESOLUTION
  KERNAL.SCREEN.COL = PEEK($030D)-1 : REM SCREEN SIZE COLS (REG.X)
  KERNAL.SCREEN.ROW = PEEK($030E)-1 : REM SCREEN SIZE ROWS (REG.Y)
  RETURN

SCREEN.CONTENT.GET:
  SCREEN.CONTENT.ADDR=$B000+(SCREEN.CONTENT.ROW*256)+SCREEN.CONTENT.COL
  SCREEN.CONTENT.COLOR=VPEEK(1,SCREEN.CONTENT.ADDR)
  SCREEN.CONTENT.CHAR=VPEEK(1,SCREEN.CONTENT.ADDR+1)
  RETURN
	
	
REM CONVERT PETSCII CODE TO SCREEN CODE/DISPLAY CODE
PETSCII.TO.DISPLAYCODE.CVT:
  IF A>= 32 AND A<=63  THEN C=A
  IF A>= 64 AND A<=95  THEN C=A-64
  IF A>= 96 AND A<=127 THEN C=A-32
  IF A>=160 AND A<=191 THEN C=A-64
  IF A>=192 AND A<=254 THEN C=A-128
  IF A=255 THEN C=A-161
	RETURN
