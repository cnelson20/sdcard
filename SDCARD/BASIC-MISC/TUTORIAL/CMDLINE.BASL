  GOSUB COLLECTARGS:REM MUST BE DONE IMMEDIATELY, BEFORE CLS OR ANYTHING ELSE
	REM OUTPUT: AN = NUMBER OF ARGUMENTS
	REM OUTPUT: AG$(N) = ARGUMENT STRING, N=0 TO AN-1
	REM IF AN=0 THEN NO ARGUMENTS WERE SPECIFIED
	
	IF AN=0 THEN PRINT "NO ARGUMENTS WERE SPECIFIED":GOTO THEEND
	
  FOR I = 0 TO AN-1
	  PRINT "ARG";(I+1);"=[";AG$(I);"]"
	NEXT I
	
	N = VAL(AG$(0))
	PRINT "N=";N
	IF N<1 THEN GOTO THEEND
	
	FOR I = 1 TO N
	  PRINT I,AG$(1)
	NEXT I	

THEEND:
END

REM *****************************************************
REM *****************************************************
REM *****************************************************
REM CALL THIS ONLY ONCE (INITIALIZES DIM SA ARRAY)
COLLECTARGS:

  REM GET CURSOR X/Y POSITION IMMEDIATELY AFTER THE RUN (X=ROW, Y=COLUMN)
  POKE $030F,1  REM SET CARRY FLAG TO GET X/Y
  SYS $FFF0 REM CALL PLOT
  R=PEEK($030D) REM GET REGISTER X RESULT (ROW)
  C=PEEK($030E) REM GET REGISTER Y RESULT (COL)

  GOSUB GETSCREENRES:REM DETERMINE THE CURRENT SCREEN RESOLUTION (PASSED ARGUMENTS MUST FIT ON SINGLE ROW)  
  
  DIM SA(255):REM SCREEN PLOT TO ASCII/PETSCII CONVERSION ARRAY
  RESTORE SCREEN2NSCII:REM SCREEN CONTENT IS IN DISPLAY CODES, WHILE BASIC STRING STUFF IS IN PETSCII
	
	I=0
NEXTREADEXTA:REM READ NEXT EXCHANGE TABLE ENTRY
  READ X
  IF X=-1 THEN GOTO INITEXTACOMP
    SA(I)=X
		I=I+1
 	GOTO NEXTREADEXTA
INITEXTACOMP:  REM INIT EXCHANGE TABLE COMPLETE

  REM READ SCREEN CONTENT FROM CURRENT COLUMN POSITION TO END OF THE CURRENT SCREEN RESOLUTION
  PS$=""
	R=R-1:REM GO UP A ROW
  FOR I = C TO SX
    A=VPEEK(1,$B000+((256*R)+(I*2)))	
  	PS$=PS$+CHR$(SA(A))
  NEXT I
	REM EVERYTHING ON THE "RUN" LINE SHOULD NOW BE IN PS$, CONVERTED FROM SCREEN CODES TO PETSCII/ASCII
	
  REM NOW LOOK FOR THE WORD "RUN"...
  FOR I = C TO SX-7:REM "-7" BECAUSE IF HAVEN'T FOUND IT BY THEN, IT'S HOPELESS (NO REMAINING ROOM)
    ZZ$=MID$(PS$,I+1,3)	
    IF ZZ$="RUN" THEN GOTO FOUNDAGRUN
  NEXT I
  GOTO GIVEAGUP:REM DID NOT FIND "RUN", NO ARGUMENTS DETECTED...

FOUNDAGRUN:
	REM NOW LOOK FOR THE WORD "REM"... I.E. RUN:REM BLAH
  C=I+3 : REM SKIP "RUN"...
	FOR I = C TO SX-2:REM "-2" BECAUSE IF HAVEN'T FOUND IT BY THEN, IT'S USELESS- NO REMAINING ROOM
	  ZZ$=MID$(PS$,I,3)
	  IF ZZ$="REM" THEN GOTO FOUNDAGREM
	NEXT I	
	GOTO GIVEAGUP:REM DID NOT FIND "REM", NO ARGUMENTS DETECTED OR MALFORMED...
	
	AN=0:REM ARGUMENT INDEX
	DIM AG$(9):REM SUPPORT UP TO 9 ARGUMENTS
FOUNDAGREM:	
  C=I+4 : REM "+4" TO SKIP "REM " (ONE WHITESPACE REQUIRED AFTER REM)
	QU=0
	FOR I = C TO SX
	  ZZ$=MID$(PS$,I,1)
		IF ZZ$=CHR$(34) THEN GOTO HANDLEAGQUOT
		IF ZZ$=" " AND QU=0 THEN AN=AN+1:GOTO SKIPAGNEXT
		AG$(AN)=AG$(AN)+ZZ$
		GOTO NEXTAGCHAR
SKIPAGNEXT:		
    ZZ$=MID$(PS$,I,2)
		IF ZZ$="  " THEN GOTO FOUNDARGS
		GOTO NEXTAGCHAR

HANDLEAGQUOT:
    IF QU=0 THEN GOTO STARTAGQU
    REM ELSE...END ARGUMENT QUOTE MODE		
		QU=0
		GOTO NEXTAGCHAR
STARTAGQU:		
    QU=1
		GOTO NEXTAGCHAR
		
NEXTAGCHAR:		
	NEXT I
	
FOUNDARGS:
GIVEAGUP:
  REM DEBUG STUFF...
  REM PRINT "CURSOR POS [";C;" X ";R;"]"
  REM PRINT "SCREEN RES IS [";SX;" X ";SY;"]"  
  REM PRINT PS$
  RETURN
	
REM RESULTS PLACED IN SX AND SY (SX=SCREEN COLUMNS, SY=SCREEN ROWS)
GETSCREENRES:
  SYS $FFED:REM SYS CALL TO GET CURRENT SCREEN RESOLUTION
	SX = PEEK($030D)-1 : REM SCREEN SIZE X (COL) 
	SY = PEEK($030E)-1 : REM SCREEN SIZE Y (ROWS)
	RETURN

SCREEN2NSCII:
REM DON'T TAKE OUT THE 0'S, THE OFFSET/INDEX IS IMPORTANT HERE
DATA 64 :REM @  IDX 0
DATA 65 :REM A  IDX 1
DATA 66 :REM B  IDX 2
DATA 67 :REM C  IDX 3
DATA 68 :REM D  IDX 4
DATA 69 :REM E  IDX 5
DATA 70 :REM F  IDX 6
DATA 71 :REM G  IDX 7
DATA 72 :REM H  IDX 8
DATA 73 :REM I  IDX 9
DATA 74 :REM J  IDX 10
DATA 75 :REM K  IDX 11
DATA 76 :REM L  IDX 12
DATA 77 :REM M  IDX 13
DATA 78 :REM N  IDX 14
DATA 79 :REM O  IDX 15
DATA 80 :REM P  IDX 16
DATA 81 :REM Q  IDX 17
DATA 82 :REM R  IDX 18
DATA 83 :REM S  IDX 19
DATA 84 :REM T  IDX 20
DATA 85 :REM U  IDX 21
DATA 86 :REM V  IDX 22
DATA 87 :REM W  IDX 23
DATA 88 :REM X  IDX 24
DATA 89 :REM Y  IDX 25
DATA 90 :REM Z  IDX 26
DATA 91 :REM [  IDX 27
DATA 0  :REM POUND  IDX 28
DATA 93 :REM ]  IDX 29
DATA 0  :REM UP IDX 30
DATA 0  :REM LEFT   IDX 31
DATA 32 :REM SPACE  IDX 32
DATA 33 :REM !  IDX 33
DATA 34 :REM "  IDX 34
DATA 35 :REM #  IDX 35
DATA 36 :REM $  IDX 36
DATA 37 :REM %  IDX 37
DATA 38 :REM &  IDX 38
DATA 39 :REM '  IDX 39
DATA 40 :REM (  IDX 40
DATA 41 :REM )  IDX 41
DATA 42 :REM *  IDX 42
DATA 43 :REM +  IDX 43
DATA 44 :REM ,  IDX 44
DATA 45 :REM -  IDX 45
DATA 46 :REM .  IDX 46
DATA 47 :REM /  IDX 47
DATA 48 :REM 0  IDX 48
DATA 49 :REM 1  IDX 49
DATA 50 :REM 2  IDX 50
DATA 51 :REM 3  IDX 51
DATA 52 :REM 4  IDX 52
DATA 53 :REM 5  IDX 53
DATA 54 :REM 6  IDX 54
DATA 55 :REM 7  IDX 55
DATA 56 :REM 8  IDX 56
DATA 57 :REM 9  IDX 57
DATA 58 :REM :  IDX 58
DATA 59 :REM ;  IDX 59 
DATA 60 :REM <  IDX 60
DATA 61 :REM =  IDX 61
DATA 62 :REM >  IDX 62
DATA 63 :REM ?  IDX 63
DATA 0  :REM BAR  IDX 64
DATA 65 :REM A  IDX 65
DATA 66 :REM B  IDX 66
DATA 67 :REM C  IDX 67
DATA 68 :REM D  IDX 68
DATA 69 :REM E  IDX 69
DATA 70 :REM F  IDX 70
DATA 71 :REM G  IDX 71
DATA 72 :REM H  IDX 72
DATA 73 :REM I  IDX 73
DATA 74 :REM J  IDX 74
DATA 75 :REM K  IDX 75
DATA 76 :REM L  IDX 76
DATA 77 :REM M  IDX 77
DATA 78 :REM N  IDX 78
DATA 79 :REM O  IDX 79
DATA 80 :REM P  IDX 80
DATA 81 :REM Q  IDX 81
DATA 82 :REM R  IDX 82
DATA 83 :REM S  IDX 83
DATA 84 :REM T  IDX 84
DATA 85 :REM U  IDX 85
DATA 86 :REM V  IDX 86
DATA 87 :REM W  IDX 87
DATA 88 :REM X  IDX 88
DATA 89 :REM Y  IDX 89
DATA 90 :REM Z  IDX 90
DATA -1
REM ASSUME REMAINING VALUES >90 AREN'T VALID COMMAND LINE ARGUMENT CHARACTERS
