#INCLUDE "STANDARD.BI"

REM ML HELPER ROUTINE TO BE POKED IN AT $0700.
BVWRITE:
 DATA $9C,$44,$07,$A9,$2C,$8D,$45,$07,$A9,$01,$8D,$46,$07,$A2,$23,$A0,$9F
 DATA $AD,$44,$07,$38,$20,$44,$FF,$B0,$29,$8E,$47,$07,$AD,$44,$07,$38,$ED
 DATA $47,$07,$8D,$44,$07,$AD,$45,$07,$8C,$47,$07,$ED,$47,$07,$8D,$45,$07
 DATA $AD,$46,$07,$E9,$00,$8D,$46,$07,$0D,$44,$07,$0D,$45,$07,$D0,$CA,$60

REM PROGRAM STARTS HERE (GOTO MAIN IN STANDARD.BI)
MAIN:
  A=$0700
  RESTORE BVWRITE
  FOR I=1 TO 68
      READ C
      POKE A,C
      A=A+1
  NEXT I
  LOADER=$0700
  USEML%=TRUE

REM ALLOCATE SPACE FOR THE BMX FILE HEADER
BMX.HDR$=RPT$(32,32)
REM SET GRAPHICS MODE
SCREEN $80

START:
  CLS
  RECT$ 0,0,319,239 ,$0
  COLOR 1,0
  LOCATE 15,2:PRINT WHITE$;"ENTER THE WORD ";YELLOW$;"<EXIT>";WHITE$;" TO END."
  LOCATE 1,1
  PRINT:PRINT
  PRINT " ENTER BMX FILENAME ";GREEN$
  PRINT
ELOOP:
  IT=4:IX=2:IY=5:ML=37:COLOR 5,11
  GOSUB STRINGGET
  F$=IS$
  IF F$="" THEN FMDRUM 7,87:GOTO ELOOP
  COLOR 1,0
  PRINT:PRINT
  IF F$="EXIT" THEN SHOWHEADER%=FALSE:GOTO SKIP1
  T$=F$:S$=".":GOSUB INSTR
  IF ISTR=0 THEN F$=F$+".BMX"
  GOSUB FILEEXISTS
  IF NOT FE% THEN PRINT " ";RED$;F$;WHITE$;"  NOT FOUND!":SLEEP 90:GOTO START
  GOSUB LOADBMX
  IF WASERROR THEN SLEEP 90:GOTO START

FLUSHKEYS:
  GET X$:IF X$<>"" THEN FLUSHKEYS
GETKEY:
  GET X$:IF X$="" THEN GETKEY
 IF X$=CHR$(27) THEN SKIP1
 IF X$=CHR$(133) THEN SHOWHEADER%=NOT SHOWHEADER%:CLS
 IF X$=CHR$(133) AND SHOWHEADER% THEN PRINT:PRINT:GOSUB SHOWHEADERINFO
 IF X$=CHR$(133) THEN GETKEY
 J=10
 JJ=INT(RND(0)*11) + 1
 VPOKE 1,$FA00,0
 VPOKE 1,$FA01,0
 ON JJ GOSUB LEFT2RIGHT, RIGHT2LEFT,PAL2BLACK,TOP2BOTTOM,BOTTOM2TOP, ALTLINEWIPE,CIRCULARWIPE,BAR1WIPE,BLOCKWIPE,DIAGONALWIPE,RDIAGONALWIPE
 RECT 0,0,XLIMIT,YLIMIT,0
 GOSUB SETDEFPAL
 GOTO START
SKIP1:
   RECT 0,0,XLIMIT,YLIMIT,0
   GOSUB SETDEFPAL
   IF SHOWHEADER% THEN SLEEP 180
   IF NOT SHOWHEADER% THEN SCREEN 1
  END

PARSEHEADER:
    BMX.ID$=LEFT$(BMX.HDR$,3)
    BMX.VER=ASC(MID$(BMX.HDR$,4,1))
    BMX.BITS = ASC(MID$(BMX.HDR$,5,1))
    BMX.VERA.REG=ASC(MID$(BMX.HDR$,6,1))
    BMX.WIDTH = ASC(MID$(BMX.HDR$,7,1)) + (ASC(MID$(BMX.HDR$,8,1))*256)
   BMX.HEIGHT = ASC(MID$(BMX.HDR$,9,1)) + (ASC(MID$(BMX.HDR$,10,1))*256)
   BMX.PALUSED = ASC(MID$(BMX.HDR$,11,1)):IF BMX.PALUSED=0 THEN BMX.PALUSED=256
   BMX.FIRSTPAL = ASC(MID$(BMX.HDR$,12,1))
   BMX.FILE.OFFSET = ASC(MID$(BMX.HDR$,13,1))+(ASC(MID$(BMX.HDR$,14,1))*256)
   BMX.COMPRESS= ASC(MID$(BMX.HDR$,15,1))
   RETURN

SHOWHEADERINFO:
   PRINT WHITE$;"BMX FILE: ";GREEN$;F$;WHITE$
   PRINT RPT$(ASC("-"),LEN(F$)+10)
   PRINT
   PRINT "        BMX HEADER ID: ";GREEN$;BMX.ID$;WHITE$
   PRINT "          BMX VERSION: ";GREEN$;ASC(MID$(BMX.HDR$,4,1));WHITE$
   PRINT "            BIT DEPTH: ";GREEN$;ASC(MID$(BMX.HDR$,5,1));WHITE$
   PRINT "       VERA DEPTH REG: ";GREEN$;BMX.VERA.REG;WHITE$
   PRINT "                WIDTH: ";GREEN$;BMX.WIDTH;WHITE$
   PRINT "               HEIGHT: ";GREEN$;BMX.HEIGHT;WHITE$
   PRINT " PALLETE ENTRIES USED: ";GREEN$;BMX.PALUSED;WHITE$
   PRINT "      PAL INDEX START: ";GREEN$;BMX.FIRSTPAL;WHITE$
   PRINT " IMG DATA FILE OFFSET: ";GREEN$;BMX.FILE.OFFSET;WHITE$
   PRINT "    IMAGE COMPRESSION:  ";GREEN$;
   IF BMX.COMPRESS <> 0 THEN PRINT "LZSA":GOTO ENDHSHOW
   PRINT "NONE"
ENDHSHOW:
   PRINT WHITE$
RETURN

LOADBMX:
     CLS:PRINT:PRINT
     OPEN 4,8,4,F$+",S,R"
     POKE X.REG, 4
     SYS CHKIN
     POKE A.REG, 32
## GET A POINTER TO THE BMX.HDR STRING THEN PEEK
## IT FOR THE ADDRESS TO THE STRING DATA
     A=POINTER(BMX.HDR$)+1
     POKE X.REG, PEEK(A)
     POKE Y.REG, PEEK(A+1)
     POKE C.REG, 0
     SYS MACPTR
     WASERROR = 0
     GOSUB PARSEHEADER
     IF BMX.ID$<>"BMX" THEN CLOSE 4:SYS CLRCHN:PRINT RED$;F$;WHITE$;" IS NOT A BMX FILE":WASERROR=-1:RETURN
     IF BMX.BITS<>8 THEN CLOSE 4:PRINT RED$;BMX.BITS;WHITE$;" BITS NOT SUPPORTED":WASERROR=-1:RETURN
     IF BMX.VER<>1 THEN CLOSE 4:SYS CLRCHN:PRINT RED$;F$;WHITE$;" IS VERSION:";RED$;BMX.VER;WHITE$;" NOT SUPPORTED!":WASERROR=-1:RETURN
     IF BMX.WIDTH > 320 THEN CLOSE 4:SYS CLRCHN:PRINT RED$;BMX.WIDTH;WHITE$;" WIDTH NOT CURRENTLY SUPPORTED":WASERROR=-1:RETURN

## READ IN THE PALETTE
    I=0
    BYTESTOGET = BMX.PALUSED*2
    VADDR = $FA00 + BMX.FIRSTPAL*2
    V.LB = (VADDR + 65536 * (VADDR > 32767)) AND $00FF
    V.HB = INT(VADDR/256)
    POKE VERA.CTRL,0
    POKE VERA.LOWADDR,V.LB
    POKE VERA.MIDADDR,V.HB
    POKE VERA.HIGHADDR, %00010001
DOIT2:
   BYTES=BYTESTOGET-I
   IF BYTES>128 THEN BYTES=128
   POKE A.REG,BYTES
   POKE X.REG, $23
   POKE Y.REG, $9F
   POKE C.REG, $01
   SYS MACPTR
   I = I + PEEK(X.REG)+(PEEK(Y.REG)*256)
   IF I < BYTESTOGET THEN DOIT2

## NOW WE LOAD THE IMAGE TO VERA
    IF BMX.WIDTH <> 320 THEN GOSUB READSMALLIMAGE:GOTO ENDLOAD
    IMG.SIZE = BMX.WIDTH * BMX.HEIGHT
    I=0
    POKE VERA.CTRL,0
    POKE VERA.LOWADDR,$00
    POKE VERA.MIDADDR,$00
    POKE VERA.HIGHADDR, %00010000
    IF BMX.HEIGHT = 240 THEN CHEK
    X=0
    Y=(YLIMIT-BMX.HEIGHT)/2
    POKE R0L,0
    POKE R0H,0
    POKE R1L,Y
    POKE R1H,0
    SYS FB.CURSOR.POSITION
    GOTO SLOOP
CHEK:
    IF NOT USEML% THEN SLOOP
    SYS LOADER
    GOTO ENDLOAD
SLOOP:
      POKE A.REG, $FF
      POKE X.REG, $23
      POKE Y.REG, $9F
      POKE C.REG, $01
      SYS MACPTR
      I=I+PEEK(X.REG)
      IF I< IMG.SIZE THEN SLOOP
ENDLOAD:
    SYS CLRCHN
    CLOSE 4:RETURN

READSMALLIMAGE:
   Y1=((YLIMIT+1)-BMX.HEIGHT)/2
   IF Y1<0 THEN Y1=0
   X1=((XLIMIT+1)-BMX.WIDTH)/2
   POKE R0L,X1
   POKE R0H, 0
   POKE R1L,Y1
   POKE R1H, 0
   SYS FB.CURSOR.POSITION
   END.Y=BMX.HEIGHT
   IF ENDY>240 THEN END.Y=240
   FOR Y= 1 TO END.Y
       I=0
       BYTESTOGET = BMX.WIDTH
   INLOOP:
       BYTES = BYTESTOGET - I
       IF BYTES>$FF THEN BYTES=$FF
       POKE A.REG, BYTES
       POKE X.REG, $23
       POKE Y.REG, $9F
       POKE C.REG, $01
       SYS MACPTR
       I=I+PEEK(X.REG)
       IF I<BYTESTOGET THEN INLOOP
       SYS FB.CURSOR.NEXTLINE
    NEXT
    RETURN

STRINGGET:
     GET X$:IF X$<>"" THEN STRINGGET
     IS$="":ID=0
     GOSUB AREACLR:IF IS$="" THEN PRINT CHR$(95);
     IF IS$<> "" THEN PRINT IS$;CHR$(95);
GETAKEY3:
     GET X$:IF X$="" THEN GETAKEY3
     C=ASC(X$)
     AC=0
     IF (IT<>2 OR IT=3) AND C>=65 AND C<=90 THEN AC=1
     IF (IT=2 OR IT=4 OR IT=3) AND C>=48 AND C<=57 THEN AC=1
     IF ((IT=2) AND C=46 AND ID=0) OR IT=3 THEN AC=1:ID=1
     IF (IT=4) AND C=32 THEN AC=1: REM ALLOW SPACES WHEN INPUTTING A LINE
     IF (IT=4) AND (C>=35 AND C<=47) THEN AC=1
     IF (IT=4) AND (C>=58 AND C<=63) THEN AC=1  : REM ALLOW PUNCS IN STRING.
     IF C=13 THEN S$=IS$:GOSUB RTRIM:IS$=S$:RETURN
     IF ((AC=1 AND LEN(IS$)<ML) AND C<>20 AND C<>27) THEN IS$=IS$+CHR$(C):FMDRUM 7,26:LOCATE IY,IX:PRINT IS$;CHR$(95);:GOTO GETAKEY3
     IF C<>20 AND C<>27 THEN TOLONG
     AC=0
     IF (IS$="" OR IS$=CHR$(27)) AND C=27 THEN IS$=CHR$(27):RETURN
     IF LEN(IS$)=0 THEN FMDRUM 7,87
     IF LEN(IS$)=1 OR LEN(IS$)=0 THEN IS$="":GOSUB AREACLR:GOTO GETAKEYEND
     I=LEN(IS$)-1
     IF RIGHT$(IS$,1)="." AND IT=2 THEN ID=0
     S$=IS$
     I=LEN(S$)-1
     IS$=MID$(S$,1,I)
GETAKEYEND:
     GOSUB AREACLR:PRINT IS$;CHR$(95);:FMDRUM 7,26:GOTO GETAKEY3
TOLONG:
     FMDRUM 7,87:GOTO GETAKEY3

AREACLR:
     LOCATE IY,IX:PRINT RPT$(32,ML+1);
     LOCATE IY,IX
     RETURN

RTRIM:
    IF S$="" THEN RETURN
    Z=LEN(S$):CC=0
DOLOOPR:
    T$=MID$(S$,Z,1)
    X=ASC(T$)
    IF X > 32 THEN RSTR
    CC=CC+1
    Z=Z-1
    IF Z<1 THEN RSTR
    GOTO DOLOOPR
RSTR:
    IF CC=LEN(S$) THEN S$=""
    IF CC>0 AND CC<LEN(S$) THEN S$=MID$(S$,1,LEN(S$)-CC)
    RETURN


## BELOW IS CODE FOR VARIOUS FADE TRANSITIONS

LEFT2RIGHT:
   FOR X = 0 TO XLIMIT
       LINE X,0,X,YLIMIT,0
       FOR D=1 TO J:NEXT D
   NEXT X
   RETURN

RIGHT2LEFT:
   FOR X = XLIMIT TO 0 STEP -1
       LINE X,0,X,YLIMIT,0
       FOR D=1 TO J:NEXT D
   NEXT X
   RETURN

TOP2BOTTOM:
   FOR Y=0 TO YLIMIT
       LINE 0,Y,XLIMIT,Y,0
       FOR D=1 TO J:NEXT D
   NEXT
   RETURN

BOTTOM2TOP:
   FOR Y=YLIMIT TO 0 STEP -1
       LINE 0,Y,XLIMIT,Y,0
       FOR D=1 TO J:NEXT D
   NEXT
   RETURN

ALTLINEWIPE:
   FOR Y = 0 TO YLIMIT STEP 4
       LINE 0,Y,XLIMIT,Y,0
       FOR D=1 TO J:NEXT D
   NEXT Y
   FOR Y = YLIMIT TO 0 STEP -3
       LINE 0,Y,XLIMIT,Y,0
       FOR D=1 TO J:NEXT D
   NEXT Y
   FOR Y = 0 TO YLIMIT STEP 2
       LINE 0,Y,XLIMIT,Y,0
       FOR D=1 TO J:NEXT D
   NEXT Y
   FOR Y = YLIMIT TO 0 STEP -2
       LINE 0,Y,XLIMIT,Y,0
       FOR D=1 TO J:NEXT D
   NEXT Y
   RETURN

CIRCULARWIPE:
    OX=(XLIMIT+1)/2
    OY=(YLIMIT+1)/2

    FOR X2 = OX TO XLIMIT
        LINE OX,OY,X2,0,0
    NEXT X2

    FOR Y2 = 0 TO YLIMIT
        LINE OX,OY,XLIMIT,Y2,0
    NEXT Y2

    FOR X2 = XLIMIT TO 0 STEP -1
        LINE OX,OY,X2,YLIMIT,0
    NEXT X2

    FOR Y2 = YLIMIT TO O STEP -1
        LINE OX,OY,0,Y2,0
    NEXT Y2

    FOR X2 = O TO OX
        LINE OX,OY,X2,0,0
    NEXT X2
    RETURN

BAR1WIPE:
  FOR Y = 0 TO 230 STEP 10
      FOR X = 0 TO 310 STEP 20
          RECT X,Y,X+9,Y+9,0
      NEXT X
  NEXT Y
  FOR Y = 0 TO 230 STEP 10
      FOR X = 10 TO 310 STEP 20
          RECT X,Y,X+9,Y+9,0
      NEXT X
  NEXT Y
  RETURN

BLOCKWIPE:
   FOR Y = 0 TO 230 STEP 10
       X2=0
       IF Y/20 = INT(Y/20) THEN X2=10
       FOR X = X2 TO 310 STEP 20
           RECT X,Y,X+9,Y+9,0
           FOR D=1 TO J:NEXT D
       NEXT X
   NEXT Y
   FOR Y = 230 TO 0 STEP -10
       X2=10
       IF Y/20 = INT(Y/20) THEN X2=0
       FOR X = X2 TO 310 STEP 20
           RECT X,Y,X+9,Y+9,0
           FOR D=1 TO J:NEXT D
       NEXT X
   NEXT Y
   RETURN

RDIAGONALWIPE:
  X1=XLIMIT:X2=XLIMIT:Y1=YLIMIT:Y2=YLIMIT
RDLOOP1:
  LINE X1,Y1,X2,Y2,0
  IF X1>0 THEN X1=X1-1
  IF Y2>0 THEN Y2=Y2-1
  IF X1>0 OR Y2>0 THEN RDLOOP1
RDLOOP2:
  LINE X1,Y1,X2,Y2,0
  IF Y1>0 THEN Y1=Y1-1
  IF X2>0 THEN X2=X2-1
  IF X2>0 OR Y1>0 THEN RDLOOP2
  RETURN

DIAGONALWIPE:
  X1=0:X2=0:Y1=0:Y2=0
DLOOP1:
  LINE X1,Y1,X2,Y2,0
  IF X2<XLIMIT THEN X2=X2+1
  IF Y1<YLIMIT THEN Y1=Y1+1
  IF X2<XLIMIT OR Y1<YLIMIT THEN DLOOP1
DLOOP2:
  LINE X1,Y1,X2,Y2,0
  IF Y2<YLIMIT THEN Y2=Y2+1
  IF X1<XLIMIT THEN X1=X1+1
  IF X1<XLIMIT OR Y2<YLIMIT THEN DLOOP2
  RETURN
