  GOSUB COLLECTARGS:REM MUST BE DONE IMMEDIATELY, BEFORE CLS OR ANYTHING ELSE
	REM OUTPUT: AN = NUMBER OF ARGUMENTS
	REM OUTPUT: AG$(N) = ARGUMENT STRING, N=0 TO AN-1
	REM IF AN=0 THEN NO ARGUMENTS WERE SPECIFIED
	
	IF AN=0 THEN GOTO SHOWUSAGE

  SYS $FFE7	
	
	GOSUB GETSCREENRES:REM SET SX(COLS) AND SY(ROWS)
	
	DV=8:REM FILE DEVICE
	SD=8:REM SUBCHANNEL
	NB=SY-3:REM DEFAULT "NUM BYTES" (OR NUM ROWS IN TEXTFILE CASE)
	FT=0:REM FORCED FILE TYPE (0=NONE/DISABLED, 1=BINARY, 2=TEXT)
	
	IF (AN>4) AND AG$(4)="B" THEN FT=1:REM SET FORCED TYPE TO BINARY
	IF (AN>4) AND AG$(4)="H" THEN FT=1:REM SET FORCED TYPE TO BINARY
	IF (AN>4) AND AG$(4)="T" THEN FT=2:REM SET FORCED TYPE TO TEXT
	IF (AN>4) AND AG$(4)="A" THEN FT=2:REM SET FORCED TYPE TO TEXT
	IF (AN>3) THEN SD=VAL(AG$(3)):REM OVERRIDE DEFAULT SUBCHANNEL
	IF (AN>2) THEN DV=VAL(AG$(2)):REM OVERRIDE DEFAULT DEVICE
	IF (AN>1) THEN NB=VAL(AG$(1)):REM OVERRIDE DEFAULT NUM. BYTES
	
	IF (NB < 1) THEN NB=1:REM LET NUM BYTE BE MINIMUM OF AT LEAST 1
	
	WT=1:REM WRAP TEXT ENABLE=1, DISABLE=0 (APPLIES FOR TEXTFILE ONLY)
	C=1
	L=1
	CC=0

	
	FI$=AG$(0)
	FI$=FI$+",S,R"
	
	OPEN 1,DV,SD,FI$
	
	OPEN 15,DV,15
	INPUT#15,RE,RE$:REM RE=RESULT ERROR
	CLOSE 15	
	ZZ=LEN(RE$)
	FOR I=1 TO ZZ-2
	  ZZ$=MID$(RE$,I,2)
		IF ZZ$="OK" THEN GOTO PROCEED
	NEXT I
	
	PRINT "[";AG$(0);"] NOT FOUND"
	GOTO DONEREADING
  
PROCEED:
  IF (FT=2) THEN GOTO RDNEXTTXT
	IF (FT=1) THEN GOTO RDNEXTBIN
	NN=64:REM NUMBER OF BYTES DURING DETECTION PHASE...
	DIM IB(NN+2):REM INPUT BUFFER
  FOR I = 1 TO NN
    BINPUT#1,ZZ$,1
		
    REM ST=64 EOF OF REACHED
    REM ST=66 READING PAST EOF

    REM IF REACH END WITHOUT DETECTING BINARY, THEN ASSUME TEXT...
		IF (ST AND 66)=66 THEN GOTO HANDLEASTEXT
		
		IB(I)=ASC(ZZ$)
		IF (IB(I)=9) THEN GOTO IGNORTHISONE
		IF ((IB(I)=10) OR (IB(I)=13)) THEN GOTO IGNORTHISONE
    IF (IB(I)<32) OR (IB(I)>126) THEN GOTO HANDLEASBIN
		
	  REM PRINT "[";ZZ$;"]",RE,RE$,ST
IGNORTHISONE:
		
	NEXT I
	
HANDLEASTEXT:
  NN=I-1
	REM CR LF  CR=0D 13 CARRIAGE FEED,  LF=0A 10 LINE FEED
  FOR I = 1 TO NN
	  GOSUB CHECKESC
	  IF (IB(I)=9) AND (C < SX) THEN PRINT " ";:GOTO FIXEDTAB
	  IF (IB(I)=13) THEN GOTO SKIPTHIS
		IF (IB(I)=10) THEN L=L+1:C=1:PRINT:GOTO CHECKLINE
		IF (C < SX) THEN PRINT CHR$(IB(I));:GOTO FIXEDTAB
		IF WT<>0 THEN PRINT CHR$(IB(I)):L=L+1:C=1:REM EARLIER PRINT TAKES US TO NEW LINE
CHECKLINE:
		IF (L>NB) THEN GOTO DONEREADING
		
		GOTO SKIPTHIS
FIXEDTAB:
		C=C+1
SKIPTHIS:
    REM SAFETY/BLANK
	NEXT I

RDNEXTTXT:
  GOSUB CHECKESC
	BINPUT#1,ZZ$,1
	IF (ST AND 66)=66 THEN GOTO DONEREADING
	
	XX=ASC(ZZ$)
	IF (XX=9) AND (C < SX) THEN PRINT " ";:GOTO FIXEDTAB2
  IF (XX=13) THEN GOTO SKIPTHIS2
	IF (XX=10) THEN L=L+1:C=1:PRINT:GOTO CHECKLINE2
	IF (C < SX) THEN PRINT CHR$(XX);:GOTO FIXEDTAB2
	IF WT<>0 THEN PRINT CHR$(XX):L=L+1:C=1:REM EARLIER PRINT TAKES US TO NEW LINE
CHECKLINE2:		
	IF (L>=NB) THEN GOTO DONEREADING
	GOTO SKIPTHIS2
FIXEDTAB2:	
	C=C+1
SKIPTHIS2:	
	GOTO RDNEXTTXT

HANDLEASBIN:
  NN=I
	FOR I = 1 TO NN	  	  
	  GOSUB CHECKESC
		PRINT HEX$(IB(I));" ";
		C=C+3
		IF (C>=(SX-1)) THEN PRINT:C=0
		
    CC=CC+1
		IF CC>=NB THEN GOTO DONEREADING		
	NEXT I
	
RDNEXTBIN:	
  GOSUB CHECKESC
	BINPUT#1,ZZ$,1	 
	IF (ST AND 66)=66 THEN GOTO DONEREADING
	
	XX=ASC(ZZ$)
	PRINT HEX$(XX);" ";
	C=C+3
	IF (C>=(SX-1)) THEN PRINT:C=0	
	
  CC=CC+1
	IF CC>=NB THEN GOTO DONEREADING
		
	GOTO RDNEXTBIN

DONEREADING:	
	CLOSE 1	
	PRINT

THEEND:
  END


CHECKESC:
  GET A$
	A=ASC(A$)
	IF (A=27) THEN GOTO DONEREADING
	RETURN
	
SHOWUSAGE:
  REM    1234567890123456789012345678901234567890
  PRINT "USAGE:"
  PRINT "RUN:<FILENAME> [N] [DEV] [SUB] [B:T]"
	PRINT "  <FILENAME> = FILENAME TO DISPLAY"
	PRINT "  [N] = DEFAULTS TO NUM. ROWS"
	PRINT "        FOR TEXT FILE, SHOW [N] ROWS"
	PRINT "        FOR BIN FILE, SHOW [N] BYTES"
	PRINT "  [DEV] = DEVICE ID, DEFAULT #8"
	PRINT "  [SUB] = SUBCHANNEL, DEFAULT #8"
	PRINT "  [B:T] = B/H FORCE AS BIN"
	PRINT "          T/A FORCE AS TXT"
	PRINT "DURING DISPLAY OF FILE,"
	PRINT "PRESS ESCAPE TO EXIT EARLY"
	PRINT "EXAMPLES:"
	PRINT "RUN:MYFILE.TXT  (AUTO DETECT TYPE)"
	PRINT "RUN:SOMEDATA.BIN 256"
	PRINT "RUN:SPECIAL.PRG 16 9"
	PRINT "RUN:NEWFILE.PRG 1000 8 6 B"	
	GOTO THEEND	

REM *****************************************************
REM *****************************************************
REM *****************************************************
REM CALL THIS ONLY ONCE (INITIALIZES DIM SA ARRAY)
COLLECTARGS:

  REM GET CURSOR X/Y POSITION IMMEDIATELY AFTER THE RUN (X=ROW, Y=COLUMN)
  POKE $030F,1  REM SET CARRY FLAG TO GET X/Y
  SYS $FFF0 REM CALL PLOT
  R=PEEK($030D) REM GET REGISTER X RESULT (ROW)
  C=PEEK($030E) REM GET REGISTER Y RESULT (COL)

  GOSUB GETSCREENRES:REM DETERMINE THE CURRENT SCREEN RESOLUTION (PASSED ARGUMENTS MUST FIT ON SINGLE ROW)  
  
  DIM SA(255):REM SCREEN PLOT TO ASCII/PETSCII CONVERSION ARRAY
  RESTORE SCREEN2NSCII:REM SCREEN CONTENT IS IN DISPLAY CODES, WHILE BASIC STRING STUFF IS IN PETSCII
	
	I=0
NEXTREADEXTA:REM READ NEXT EXCHANGE TABLE ENTRY
  READ X
  IF X=-1 THEN GOTO INITEXTACOMP
    SA(I)=X
		I=I+1
 	GOTO NEXTREADEXTA
INITEXTACOMP:  REM INIT EXCHANGE TABLE COMPLETE

  REM READ SCREEN CONTENT FROM CURRENT COLUMN POSITION TO END OF THE CURRENT SCREEN RESOLUTION
  PS$=""
	R=R-1:REM GO UP A ROW
  FOR I = C TO SX
    A=VPEEK(1,$B000+((256*R)+(I*2)))	
  	PS$=PS$+CHR$(SA(A))
  NEXT I
	REM EVERYTHING ON THE "RUN" LINE SHOULD NOW BE IN PS$, CONVERTED FROM SCREEN CODES TO PETSCII/ASCII
	
  REM NOW LOOK FOR THE WORD "RUN"...
  FOR I = C TO SX-7:REM "-4" BECAUSE IF HAVEN'T FOUND IT BY THEN, IT'S HOPELESS (NO REMAINING ROOM)
    ZZ$=MID$(PS$,I+1,3)	
    IF ZZ$="RUN" THEN GOTO FOUNDAGRUN
  NEXT I
  GOTO GIVEAGUP:REM DID NOT FIND "RUN", NO ARGUMENTS DETECTED...

FOUNDAGRUN:
	REM NOW LOOK FOR THE WORD "REM"... I.E. RUN:REM BLAH
  C=I+3 : REM SKIP "RUN"...
	FOR I = C TO SX-2:REM "-2" BECAUSE IF HAVEN'T FOUND IT BY THEN, IT'S USELESS- NO REMAINING ROOM
	  REM IF WANT TO REQUIRE "RUN:REM "
	  REM ZZ$=MID$(PS$,I,3)
	  REM IF ZZ$="REM" THEN GOTO FOUNDAGREM
	  REM ELSE IF OK WITH JUST "RUN:" USE THIS:
	  ZZ$=MID$(PS$,I,1)
	  IF ZZ$=":" THEN GOTO FOUNDAGREM
	NEXT I	
	GOTO GIVEAGUP:REM DID NOT FIND "REM", NO ARGUMENTS DETECTED OR MALFORMED...
	
	AN=0:REM ARGUMENT INDEX
	DIM AG$(9):REM SUPPORT UP TO 9 ARGUMENTS
FOUNDAGREM:
        REM IF USING "RUN:REM "
        REM C=I+4 : REM "+4" TO SKIP "REM " (ONE WHITESPACE REQUIRED AFTER REM)	
	REM ELSE...
        C=I+1 : REM "+1" TO SKIP "REM " (ONE WHITESPACE REQUIRED AFTER REM)
	QU=0
	FOR I = C TO SX
	  ZZ$=MID$(PS$,I,1)
		IF ZZ$=CHR$(34) THEN GOTO HANDLEAGQUOT
		IF ZZ$=" " AND QU=0 THEN AN=AN+1:GOTO SKIPAGNEXT
		AG$(AN)=AG$(AN)+ZZ$
		GOTO NEXTAGCHAR
SKIPAGNEXT:		
    ZZ$=MID$(PS$,I,2)
		IF ZZ$="  " THEN GOTO FOUNDARGS
		GOTO NEXTAGCHAR

HANDLEAGQUOT:
    IF QU=0 THEN GOTO STARTAGQU
    REM ELSE...END ARGUMENT QUOTE MODE		
		QU=0
		GOTO NEXTAGCHAR
STARTAGQU:		
    QU=1
		GOTO NEXTAGCHAR
		
NEXTAGCHAR:		
	NEXT I
	
FOUNDARGS:
GIVEAGUP:
  REM DEBUG STUFF...
  REM PRINT "CURSOR POS [";C;" X ";R;"]"
  REM PRINT "SCREEN RES IS [";SX;" X ";SY;"]"  
  REM PRINT PS$
  RETURN
	
REM RESULTS PLACED IN SX AND SY (SX=SCREEN COLUMNS, SY=SCREEN ROWS)
GETSCREENRES:
  SYS $FFED:REM SYS CALL TO GET CURRENT SCREEN RESOLUTION
	SX = PEEK($030D)-1 : REM SCREEN SIZE X (COL) 
	SY = PEEK($030E)-1 : REM SCREEN SIZE Y (ROWS)
	RETURN

SCREEN2NSCII:
REM DON'T TAKE OUT THE 0'S, THE OFFSET/INDEX IS IMPORTANT HERE
DATA 64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,0,93,0,0,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,0,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80
DATA 81,82,83,84,85,86,87,88,89,90,-1
