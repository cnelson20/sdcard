  DISPLAY.CODE.OFF=32
	DISPLAY.CODE.ON=219
		
  A=RND(0)
  REM SCREEN 11
  CLS

	PRINT "TYPE IN A SHORT ONE LINE PHRASE:"
  PRINT ">";
  GET.SOME.INPUT.MAXLEN=-1:REM ANY NEGATIVE VALUES GO TO MAX.LENGTH OF CURRENT ROW
  GOSUB GET.SOME.INPUT
  PRINT "[";GET.SOME.INPUT.RESULT$;"]"
	BIG.PRINT.STRING$ = GET.SOME.INPUT.RESULT$
	
ENLARGEMENT.FACTOR.ASK:	  
	PRINT "LONGER STRINGS MUST USE LOWER ENLARGEMENT FACTORS"	
	PRINT "SPECIFY ENLARGEMENT FACTOR (1-9):"
	PRINT "#";
	GET.SOME.INPUT.MAXLEN=2
	GOSUB GET.SOME.INPUT
	BIG.PRINT.SIZEFACTOR=VAL(GET.SOME.INPUT.RESULT$)
	IF (BIG.PRINT.SIZEFACTOR < 1) OR (BIG.PRINT.SIZEFACTOR > 9) THEN GOTO ENLARGEMENT.FACTOR.ASK

  GOSUB BIG.PRINT.EXECUTE
	IF BIG.PRINT.RESULT=0 THEN GOTO ENLARGEMENT.FACTOR.ASK
	
	LOCATE KERNAL.SCREEN.ROW-2,1
  END

REM **************************************************
REM **************************************************
BIG.PRINT.EXECUTE:  
  BIG.PRINT.RESULT = 1 : REM 0 = FAILURE OR ERROR, 1 = SUCCESS
  
	GOSUB KERNAL.SCREEN.GET
  REM KERNAL.SCREEN.COL
  REM KERNAL.SCREEN.ROW
	
	BIG.PRINT.LENGTH = LEN(BIG.PRINT.STRING$)
	WHOLE.ROW.LEN = BIG.PRINT.LENGTH*(8*BIG.PRINT.SIZEFACTOR)
	BIG.PRINT.MEMORY = WHOLE.ROW.LEN*(1*(8*BIG.PRINT.SIZEFACTOR)) : REM 1 BECAUSE ONLY 1 ROW OF TEXT
	ESTIMATED.AVAIL.RAM = INT(FRE(0)*0.80)
	IF ((BIG.PRINT.MEMORY*5) > ESTIMATED.AVAIL.RAM) THEN PRINT "NEED MORE RAM (NEED ";BIG.PRINT.MEMORY*5;", HAVE ";ESTIMATED.AVAIL.RAM;")":BIG.PRINT.RESULT=0:GOTO BIG.PRINT.EXIT
	
	PRINT "INITIALIZING MEMORY WORKSPACE (";BIG.PRINT.MEMORY;CHR$(157);")"
	
	DIM BIG.PRINT.DATA(BIG.PRINT.MEMORY)
	FOR I = 0 TO BIG.PRINT.MEMORY
	  BIG.PRINT.DATA(I) = DISPLAY.CODE.OFF
	NEXT I

  PRINT "CALCULATING FONT ENLARGEMENT (FACTOR ";BIG.PRINT.SIZEFACTOR;CHR$(157);")"
	GOSUB KERNAL.PLOT.GET
	
	FOR BIG.PRINT.INDEX = 1 TO BIG.PRINT.LENGTH
	  PRINT INT((BIG.PRINT.INDEX-1)/BIG.PRINT.LENGTH*100);
		LOCATE KERNAL.PLOT.ROW+1,1
		
	  A$=MID$(BIG.PRINT.STRING$,BIG.PRINT.INDEX,1) : REM 1 == JUST GET 1 CHARACTER AT A TIME
		A = ASC(A$)
		GOSUB PETSCII.TO.DISPLAYCODE.CVT : REM RESULTING DISPLAY/SCREEN CODE IS STORED IN "C"
		
		FONT.BASE = $F000+C*8
	
		FOR FONT.ROW.IDX = 0 TO 7 : REM EACH ROW OF THE FONT...

		  A=VPEEK(1,FONT.BASE+FONT.ROW.IDX)
			A$=BIN$(A)
			
			REM "01000101"  0
			REM PRINT A$;

			FOR FONT.COL.IDX = 1 TO 8
			
			  BIT$=MID$(A$,FONT.COL.IDX,1)
				IF BIT$="0" THEN BIT=DISPLAY.CODE.OFF
				IF BIT$="1" THEN BIT=DISPLAY.CODE.ON
				
				REM PRINT BIT$;

        REM PRINT "(";
				
			  FOR SIZE.FACTOR.IDX.Y = 1 TO BIG.PRINT.SIZEFACTOR
			
          OFFSET.BASE=(WHOLE.ROW.LEN*FONT.ROW.IDX*BIG.PRINT.SIZEFACTOR)+((BIG.PRINT.INDEX-1)*8*BIG.PRINT.SIZEFACTOR)									
					OFFSET.BASE=OFFSET.BASE+(SIZE.FACTOR.IDX.Y-1)*WHOLE.ROW.LEN
					
					REM PRINT OFFSET.BASE;"+";
					
				  FOR SIZE.FACTOR.IDX.X = 1 TO BIG.PRINT.SIZEFACTOR
					  OFFSET.INDEX=(FONT.COL.IDX-1)*BIG.PRINT.SIZEFACTOR+(SIZE.FACTOR.IDX.X-1)
						REM PRINT OFFSET.INDEX;
				    BIG.PRINT.DATA(OFFSET.BASE+OFFSET.INDEX)=BIT
					NEXT SIZE.FACTOR.IDX.X
					
				NEXT SIZE.FACTOR.IDX.Y
				REM PRINT ")";

			NEXT FONT.COL.IDX			
			
			REM PRINT
			
		NEXT FONT.ROW.IDX
				
    REM PRINT A$,A,C
	NEXT BIG.PRINT.INDEX
	
	REM PRINT WHOLE.ROW.LEN;BIG.PRINT.MEMORY
	REM PRINT
	
	CLS
	WORKING.COL = 0
	WORKING.ROW = 2
	FOR I = 0 TO BIG.PRINT.MEMORY-1
	  WORKING.VALUE = BIG.PRINT.DATA(I)
		
		IF (WORKING.COL < KERNAL.SCREEN.COL) AND (WORKING.ROW < KERNAL.SCREEN.ROW) THEN TILE WORKING.COL,WORKING.ROW,WORKING.VALUE
		
		WORKING.COL=WORKING.COL+1
		IF WORKING.COL=WHOLE.ROW.LEN THEN WORKING.COL=0:WORKING.ROW=WORKING.ROW+1
	NEXT I
	
  GOTO BIG.PRINT.EXIT
	
  FOR OUTPUT.ROW = 0 TO 8*BIG.PRINT.SIZEFACTOR-1
	  OUTPUT.BASE = ROW*WHOLE.ROW.LEN
		
	  FOR OUTPUT.COL = 0 TO WHOLE.ROW.LEN
		  VALUE = BIG.PRINT.DATA(DATA.OFFSET)
		
		  DATA.OFFSET = OUTPUT.BASE+OUTPUT.COL
			IF (DATA.OFFSET > BIG.PRINT.MEMORY) THEN GOTO BIG.PRINT.EXIT
			
		  TILE OUTPUT.COL,OUTPUT.ROW,BIG.PRINT.DATA(DATA.OFFSET)
		NEXT OUTPUT.COL
	NEXT OUTPUT.ROW

BIG.PRINT.EXIT:	  
  RETURN

REM **************************************************
REM **************************************************
GET.SOME.INPUT:

  GOSUB KERNAL.PLOT.GET
	
	REM GET THE SCREEN CONTENT AT WHERE WE ARE NOW
  SCREEN.CONTENT.COL=KERNAL.PLOT.COL
  SCREEN.CONTENT.ROW=KERNAL.PLOT.ROW
  GOSUB SCREEN.CONTENT.GET

  REM GET THE CURRENT SIZE OF THE TEXT MODE SCREEN, SO WE CAN KEEP THE INPUT TO A SINGLE LINE
  GOSUB KERNAL.SCREEN.GET

  REM ABSOLUTE MAX (SCREEN COL WIDTH MINUS STARTING CURSOR COLUMN)
  GET.SOME.INPUT.ABSMAX = KERNAL.SCREEN.COL - KERNAL.PLOT.COL

  REM IF A NEGATIVE MAXLEN IS SPECIFIED, THEN DEFAULT IT BACK TO THE MAX COMPUTED LENGTH
  IF GET.SOME.INPUT.MAXLEN<0 THEN GET.SOME.INPUT.MAXLEN=GET.SOME.INPUT.ABSMAX
 
  IF GET.SOME.INPUT.MAXLEN <= GET.SOME.INPUT.ABSMAX THEN GOTO GET.SOME.INPUT.START
  GET.SOME.INPUT.MAXLEN = GET.SOME.INPUT.ABSMAX

GET.SOME.INPUT.START:
  GET.SOME.INPUT.RESULT$ = ""
  INPUT.QUERY.LENGTH=0

GET.SOME.INPUT.GET:  
  GOSUB KERNAL.PLOT.GET
  TILE KERNAL.PLOT.COL,KERNAL.PLOT.ROW,INT(RND(.)*256),INT(RND(.)*16)
  GET INPUT.QUERY$:IF INPUT.QUERY$="" THEN GOTO GET.SOME.INPUT.GET

  INPUT.QUERY = ASC(INPUT.QUERY$)

  IF INPUT.QUERY=13 THEN GOTO GET.SOME.INPUT.EXIT:REM PETSCII 13 IS RETURN/ENTER

  REM PETSCII 20 IS BACKSPACE
  IF INPUT.QUERY<>20 THEN GOTO GET.SOME.INPUT.VALIDS
  REM HANDLE BACKSPACE...
  IF LEN(GET.SOME.INPUT.RESULT$)<=0 THEN GOTO GET.SOME.INPUT.GET
  GOSUB KERNAL.PLOT.GET
  TILE KERNAL.PLOT.COL,KERNAL.PLOT.ROW,SCREEN.CONTENT.CHAR,SCREEN.CONTENT.COLOR
  GET.SOME.INPUT.RESULT$=LEFT$(GET.SOME.INPUT.RESULT$,LEN(GET.SOME.INPUT.RESULT$)-1)
  PRINT CHR$(157);" ";CHR$(157);  
  INPUT.QUERY.LENGTH=INPUT.QUERY.LENGTH-1
	GOTO GET.SOME.INPUT.GET

GET.SOME.INPUT.VALIDS:
  IF INPUT.QUERY.LENGTH=GET.SOME.INPUT.MAXLEN THEN GOTO GET.SOME.INPUT.ERROR
	
	IF INPUT.QUERY>=0 AND INPUT.QUERY<32 THEN GOTO GET.SOME.INPUT.ERROR    :REM LOWER (FIRST) 32
	IF INPUT.QUERY>=128 AND INPUT.QUERY<160 THEN GOTO GET.SOME.INPUT.ERROR :REM UPPER (INVERTED) 32
	
	REM ALTERNATIVELY - YOU CAN FILTER DOWN INTO SPECIFIC ALPHA-NUMERICS YOU WANT TO MAKE ACCAPTABLE...	
	REM IF INPUT.QUERY>=193 AND INPUT.QUERY<=218 THEN GOTO GET.SOME.INPUT.KEEP   : REM LOWER CASE IN CERTAIN MODES
  REM IF INPUT.QUERY$>="a" AND INPUT.QUERY$<="z" THEN GOTO GET.SOME.INPUT.KEEP
  REM IF INPUT.QUERY$>="A" AND INPUT.QUERY$<="Z" THEN GOTO GET.SOME.INPUT.KEEP
  REM IF INPUT.QUERY$>="0" AND INPUT.QUERY$<="9" THEN GOTO GET.SOME.INPUT.KEEP
  REM IF INPUT.QUERY$="-" OR INPUT.QUERY$="!" THEN GOTO GET.SOME.INPUT.KEEP
  REM IF INPUT.QUERY$=" " THEN GOTO GET.SOME.INPUT.KEEP
  REM GOTO GET.SOME.INPUT.GET

GET.SOME.INPUT.KEEP:
  INPUT.QUERY.LENGTH=INPUT.QUERY.LENGTH+1
  GET.SOME.INPUT.RESULT$=GET.SOME.INPUT.RESULT$+INPUT.QUERY$
  PRINT INPUT.QUERY$;
  GOTO GET.SOME.INPUT.GET

GET.SOME.INPUT.ERROR:
  PRINT CHR$(7);:REM BELL
  GOTO GET.SOME.INPUT.GET

GET.SOME.INPUT.EXIT:
  REM CLEAN UP THE LAST NON-PRINTABLE CHARACTER (RETURN/ENTER)
  GOSUB KERNAL.PLOT.GET
  TILE KERNAL.PLOT.COL,KERNAL.PLOT.ROW,SCREEN.CONTENT.CHAR,SCREEN.CONTENT.COLOR
  PRINT
  RETURN

KERNAL.PLOT.GET:
  REM GET CURSOR X/Y POSITION (X=ROW, Y=COLUMN)
  REM RESULT WRITTEN TO KERNAL.PLOT.R AND KERNAL.PLOT.C
  POKE $030F,1  REM SET CARRY FLAG TO GET X/Y
  SYS $FFF0 REM CALL PLOT
  KERNAL.PLOT.ROW=PEEK($030D) REM GET REGISTER X RESULT (ROW)
  KERNAL.PLOT.COL=PEEK($030E) REM GET REGISTER Y RESULT (COL)
  RETURN

KERNAL.SCREEN.GET:
  SYS $FFED:REM SYS CALL TO GET CURRENT SCREEN RESOLUTION
  KERNAL.SCREEN.COL = PEEK($030D)-1 : REM SCREEN SIZE COLS (REG.X)
  KERNAL.SCREEN.ROW = PEEK($030E)-1 : REM SCREEN SIZE ROWS (REG.Y)
  RETURN

SCREEN.CONTENT.GET:
  SCREEN.CONTENT.ADDR=$B000+(SCREEN.CONTENT.ROW*256)+SCREEN.CONTENT.COL
  SCREEN.CONTENT.COLOR=VPEEK(1,SCREEN.CONTENT.ADDR)
  SCREEN.CONTENT.CHAR=VPEEK(1,SCREEN.CONTENT.ADDR+1)
  RETURN
	
	
REM CONVERT PETSCII CODE TO SCREEN CODE/DISPLAY CODE
PETSCII.TO.DISPLAYCODE.CVT:
  IF A>= 32 AND A<=63  THEN C=A
  IF A>= 64 AND A<=95  THEN C=A-64
  IF A>= 96 AND A<=127 THEN C=A-32
  IF A>=160 AND A<=191 THEN C=A-64
  IF A>=192 AND A<=254 THEN C=A-128
  IF A=255 THEN C=A-161
	RETURN
