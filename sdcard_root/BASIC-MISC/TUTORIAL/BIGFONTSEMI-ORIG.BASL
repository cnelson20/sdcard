REM VOIDSTAR - DEC 2023
REM THIS IS THE ONLY "SLOW" VERSION, KEPT FOR COMPARISON WITH THE FASTER VERSION (WHICH IS ABOUT 2X AS FAST).
REM THE LOGIC USED IN THIS VERSION MAY BE MORE INTUITIVE TO THOSE NEW TO BASIC.
		
  A=RND(0)
  REM SCREEN 11
  CLS

	PRINT "TYPE IN A SHORT ONE LINE PHRASE:"
  PRINT ">";
  GET.SOME.INPUT.MAXLEN=31:REM ANY NEGATIVE VALUES GO TO MAX.LENGTH OF CURRENT ROW
  GOSUB GET.SOME.INPUT
  PRINT "[";GET.SOME.INPUT.RESULT$;"]"
	BIG.PRINT.STRING$ = GET.SOME.INPUT.RESULT$	
	
	GOSUB BIG.PRINT.EXECUTE	

	LOCATE KERNAL.SCREEN.ROW-2,1
  END

REM **************************************************
REM **************************************************
BIG.PRINT.EXECUTE:  
  BIG.PRINT.STRING.LEN = LEN(BIG.PRINT.STRING$)
	
	DIM BIG.PRINT.RESULT(16)
	
	REM GET THE CURRENT ROW SO WE CAN WRITE THE RESULT DIRECTLY TO THIS ROW...
	GOSUB KERNAL.PLOT.GET
	TMP.ROW = KERNAL.PLOT.ROW

  TMP.COL = 0	: REM MANAGE WHICH COLUMN THE PRINTED RESULT WILL BE DISPLAYED
	FOR I = 1 TO BIG.PRINT.STRING.LEN
	
	  A$= MID$(BIG.PRINT.STRING$,I,1)		
		A = ASC(A$)		
		GOSUB PETSCII.TO.DISPLAYCODE.CVT : REM C = RESULTING DISPLAY CODE 
		
		FONT.BASE = $F000+C*8 : REM *8 SINCE WE KNOW VRAM FONTS ARE 8 PIXELS(BITS) WIDE
		
		FOR FONT.ROW.IDX = 0 TO 7 STEP 2 : REM EACH ROW OF THE FONT...

		  A1=VPEEK(1,FONT.BASE+FONT.ROW.IDX)
			A2=VPEEK(1,FONT.BASE+FONT.ROW.IDX+1)
					
			REM 11000000 -> 00110000 -> 00001100 -> 00000011
			BIT.MASK=$C0
			REM   2= SHIFT 1
			REM   4= SHIFT 2
			REM   8= SHIFT 3
			REM  16= SHIFT 4
			REM  32= SHIFT 5
			REM  64= SHIFT 6
			REM 128= SHIFT 7
			
			FOR FONT.COL.IDX = 0 TO 7 STEP 2 : REM 0 2 4 6
			  CODE$=""
			  DENOM=2^(6-FONT.COL.IDX)				
			  A1.TMP = INT((A1 AND BIT.MASK) / DENOM)
				A2.TMP = INT((A2 AND BIT.MASK) / DENOM)
				
				REM ACCUMULATE CLOCKWISE
				A$="0":IF (A1.TMP AND 2) THEN A$="1"
				CODE$=CODE$+A$
				A$="0":IF (A1.TMP AND 1) THEN A$="1"
				CODE$=CODE$+A$
				A$="0":IF (A2.TMP AND 1) THEN A$="1"
				CODE$=CODE$+A$
				A$="0":IF (A2.TMP AND 2) THEN A$="1"
				CODE$=CODE$+A$
							
				BIT.MASK = INT(BIT.MASK / 4) : REM SHIFT RIGHT BY 2
			
				IF CODE$="0000" THEN NEW.CHAR=32 :GOTO BIG.FONT.GOTCHAR
				IF CODE$="0001" THEN NEW.CHAR=123:GOTO BIG.FONT.GOTCHAR
				IF CODE$="0010" THEN NEW.CHAR=108:GOTO BIG.FONT.GOTCHAR
				IF CODE$="0011" THEN NEW.CHAR=98 :GOTO BIG.FONT.GOTCHAR
				IF CODE$="0100" THEN NEW.CHAR=124:GOTO BIG.FONT.GOTCHAR
				IF CODE$="0101" THEN NEW.CHAR=255:GOTO BIG.FONT.GOTCHAR
				IF CODE$="0110" THEN NEW.CHAR=225:GOTO BIG.FONT.GOTCHAR
				IF CODE$="0111" THEN NEW.CHAR=254:GOTO BIG.FONT.GOTCHAR
				IF CODE$="1000" THEN NEW.CHAR=126:GOTO BIG.FONT.GOTCHAR
				IF CODE$="1001" THEN NEW.CHAR=97 :GOTO BIG.FONT.GOTCHAR
				IF CODE$="1010" THEN NEW.CHAR=127:GOTO BIG.FONT.GOTCHAR
				IF CODE$="1011" THEN NEW.CHAR=252:GOTO BIG.FONT.GOTCHAR
				IF CODE$="1100" THEN NEW.CHAR=226:GOTO BIG.FONT.GOTCHAR
				IF CODE$="1101" THEN NEW.CHAR=236:GOTO BIG.FONT.GOTCHAR
				IF CODE$="1110" THEN NEW.CHAR=251:GOTO BIG.FONT.GOTCHAR
				IF CODE$="1111" THEN NEW.CHAR=160
BIG.FONT.GOTCHAR:				
				
				TMP.IDX = (INT(FONT.ROW.IDX/2)*4)+INT(FONT.COL.IDX/2) : REM *4 SINCE WE KNOW WIDTH IS 4
				BIG.PRINT.RESULT(TMP.IDX) = NEW.CHAR				

			NEXT FONT.COL.IDX
			
		NEXT FONT.ROW.IDX
			
	  REM WRITE OUT THE GENERATED SEMIGRAPHIC CHARACTER...		
		FOR TMP.IDX.X = 0 TO 3
			TILE TMP.COL+TMP.IDX.X,TMP.ROW,BIG.PRINT.RESULT(TMP.IDX.X)			
			TILE TMP.COL+TMP.IDX.X,TMP.ROW+1,BIG.PRINT.RESULT(4+TMP.IDX.X)			
			TILE TMP.COL+TMP.IDX.X,TMP.ROW+2,BIG.PRINT.RESULT(8+TMP.IDX.X)			
			TILE TMP.COL+TMP.IDX.X,TMP.ROW+3,BIG.PRINT.RESULT(12+TMP.IDX.X)			
		NEXT TMP.IDX.X
		
		TMP.COL = TMP.COL + 4
		
	NEXT I

  RETURN
	

REM **************************************************
REM **************************************************
GET.SOME.INPUT:

  GOSUB KERNAL.PLOT.GET
	
	REM GET THE SCREEN CONTENT AT WHERE WE ARE NOW
  SCREEN.CONTENT.COL=KERNAL.PLOT.COL
  SCREEN.CONTENT.ROW=KERNAL.PLOT.ROW
  GOSUB SCREEN.CONTENT.GET

  REM GET THE CURRENT SIZE OF THE TEXT MODE SCREEN, SO WE CAN KEEP THE INPUT TO A SINGLE LINE
  GOSUB KERNAL.SCREEN.GET

  REM ABSOLUTE MAX (SCREEN COL WIDTH MINUS STARTING CURSOR COLUMN)
  GET.SOME.INPUT.ABSMAX = KERNAL.SCREEN.COL - KERNAL.PLOT.COL

  REM IF A NEGATIVE MAXLEN IS SPECIFIED, THEN DEFAULT IT BACK TO THE MAX COMPUTED LENGTH
  IF GET.SOME.INPUT.MAXLEN<0 THEN GET.SOME.INPUT.MAXLEN=GET.SOME.INPUT.ABSMAX
 
  IF GET.SOME.INPUT.MAXLEN <= GET.SOME.INPUT.ABSMAX THEN GOTO GET.SOME.INPUT.START
  GET.SOME.INPUT.MAXLEN = GET.SOME.INPUT.ABSMAX

GET.SOME.INPUT.START:
  GET.SOME.INPUT.RESULT$ = ""
  INPUT.QUERY.LENGTH=0

GET.SOME.INPUT.GET:  
  GOSUB KERNAL.PLOT.GET
  TILE KERNAL.PLOT.COL,KERNAL.PLOT.ROW,INT(RND(.)*256),INT(RND(.)*16)
  GET INPUT.QUERY$:IF INPUT.QUERY$="" THEN GOTO GET.SOME.INPUT.GET

  INPUT.QUERY = ASC(INPUT.QUERY$)

  IF INPUT.QUERY=13 THEN GOTO GET.SOME.INPUT.EXIT:REM PETSCII 13 IS RETURN/ENTER

  REM PETSCII 20 IS BACKSPACE
  IF INPUT.QUERY<>20 THEN GOTO GET.SOME.INPUT.VALIDS
  REM HANDLE BACKSPACE...
  IF LEN(GET.SOME.INPUT.RESULT$)<=0 THEN GOTO GET.SOME.INPUT.GET
  GOSUB KERNAL.PLOT.GET
  TILE KERNAL.PLOT.COL,KERNAL.PLOT.ROW,SCREEN.CONTENT.CHAR,SCREEN.CONTENT.COLOR
  GET.SOME.INPUT.RESULT$=LEFT$(GET.SOME.INPUT.RESULT$,LEN(GET.SOME.INPUT.RESULT$)-1)
  PRINT CHR$(157);" ";CHR$(157);  
  INPUT.QUERY.LENGTH=INPUT.QUERY.LENGTH-1
	GOTO GET.SOME.INPUT.GET

GET.SOME.INPUT.VALIDS:
  IF INPUT.QUERY.LENGTH=GET.SOME.INPUT.MAXLEN THEN GOTO GET.SOME.INPUT.ERROR
	
	IF INPUT.QUERY>=0 AND INPUT.QUERY<32 THEN GOTO GET.SOME.INPUT.ERROR    :REM LOWER (FIRST) 32
	IF INPUT.QUERY>=128 AND INPUT.QUERY<160 THEN GOTO GET.SOME.INPUT.ERROR :REM UPPER (INVERTED) 32
	
	REM ALTERNATIVELY - YOU CAN FILTER DOWN INTO SPECIFIC ALPHA-NUMERICS YOU WANT TO MAKE ACCAPTABLE...	
	REM IF INPUT.QUERY>=193 AND INPUT.QUERY<=218 THEN GOTO GET.SOME.INPUT.KEEP   : REM LOWER CASE IN CERTAIN MODES
  REM IF INPUT.QUERY$>="a" AND INPUT.QUERY$<="z" THEN GOTO GET.SOME.INPUT.KEEP
  REM IF INPUT.QUERY$>="A" AND INPUT.QUERY$<="Z" THEN GOTO GET.SOME.INPUT.KEEP
  REM IF INPUT.QUERY$>="0" AND INPUT.QUERY$<="9" THEN GOTO GET.SOME.INPUT.KEEP
  REM IF INPUT.QUERY$="-" OR INPUT.QUERY$="!" THEN GOTO GET.SOME.INPUT.KEEP
  REM IF INPUT.QUERY$=" " THEN GOTO GET.SOME.INPUT.KEEP
  REM GOTO GET.SOME.INPUT.GET

GET.SOME.INPUT.KEEP:
  INPUT.QUERY.LENGTH=INPUT.QUERY.LENGTH+1
  GET.SOME.INPUT.RESULT$=GET.SOME.INPUT.RESULT$+INPUT.QUERY$
  PRINT INPUT.QUERY$;
  GOTO GET.SOME.INPUT.GET

GET.SOME.INPUT.ERROR:
  PRINT CHR$(7);:REM BELL
  GOTO GET.SOME.INPUT.GET

GET.SOME.INPUT.EXIT:
  REM CLEAN UP THE LAST NON-PRINTABLE CHARACTER (RETURN/ENTER)
  GOSUB KERNAL.PLOT.GET
  TILE KERNAL.PLOT.COL,KERNAL.PLOT.ROW,SCREEN.CONTENT.CHAR,SCREEN.CONTENT.COLOR
  PRINT
  RETURN

KERNAL.PLOT.GET:
  REM GET CURSOR X/Y POSITION (X=ROW, Y=COLUMN)
  REM RESULT WRITTEN TO KERNAL.PLOT.R AND KERNAL.PLOT.C
  POKE $030F,1  REM SET CARRY FLAG TO GET X/Y
  SYS $FFF0 REM CALL PLOT
  KERNAL.PLOT.ROW=PEEK($030D) REM GET REGISTER X RESULT (ROW)
  KERNAL.PLOT.COL=PEEK($030E) REM GET REGISTER Y RESULT (COL)
  RETURN

KERNAL.SCREEN.GET:
  SYS $FFED:REM SYS CALL TO GET CURRENT SCREEN RESOLUTION
  KERNAL.SCREEN.COL = PEEK($030D)-1 : REM SCREEN SIZE COLS (REG.X)
  KERNAL.SCREEN.ROW = PEEK($030E)-1 : REM SCREEN SIZE ROWS (REG.Y)
  RETURN

SCREEN.CONTENT.GET:
  SCREEN.CONTENT.ADDR=$B000+(SCREEN.CONTENT.ROW*256)+SCREEN.CONTENT.COL
  SCREEN.CONTENT.COLOR=VPEEK(1,SCREEN.CONTENT.ADDR)
  SCREEN.CONTENT.CHAR=VPEEK(1,SCREEN.CONTENT.ADDR+1)
  RETURN
	
	
REM CONVERT PETSCII CODE TO SCREEN CODE/DISPLAY CODE
PETSCII.TO.DISPLAYCODE.CVT:
  IF A>= 32 AND A<=63  THEN C=A
  IF A>= 64 AND A<=95  THEN C=A-64
  IF A>= 96 AND A<=127 THEN C=A-32
  IF A>=160 AND A<=191 THEN C=A-64
  IF A>=192 AND A<=254 THEN C=A-128
  IF A=255 THEN C=A-161
	RETURN
